#!/usr/bin/python

import sys, os, os.path, string, glob, math
import random
import time
import tempfile
import subprocess
import argparse


argparser = argparse.ArgumentParser()
argparser.add_argument('-duration', dest='duration', type=int, default=60, metavar='<seconds>', help='job duration')
argparser.add_argument('-n', dest='n', type=int, default=1, metavar='<num-jobs>')
argparser.add_argument('-submitters', dest='submitters', type=int, default=1, metavar='<num-submitters>')
argparser.add_argument('-xgroups', dest='xgroups_args', default=[], nargs='*', metavar='<grp> <num>')
argparser.add_argument('-reqs', dest='reqs', default=None, metavar='<expr>', help='job requirement expression')
argparser.add_argument('-shell', dest='shell', action='store_true', default=False, help='wrap sleep in shell command')
argparser.add_argument('-err', dest='err_out', action='store_true', default=False, help='collect stderr from jobs')
argparser.add_argument('-std', dest='std_out', action='store_true', default=False, help='collect stdout from jobs')
argparser.add_argument('-log', dest='log_out', action='store_true', default=False, help='collect log from jobs')
argparser.add_argument('-ss', dest='ss', action='store_true', default=False, help='submit in steady-state mode')
argparser.add_argument('-ss-maxreps', dest='maxreps', default=None, type=int, metavar='<reps>')
argparser.add_argument('-ss-maxtime', dest='maxtime', default=None, type=int, metavar='<seconds>')
argparser.add_argument('-ss-interval', dest='interval', default=0, type=float, metavar='<seconds>')
argparser.add_argument('-append', dest='append', default=[], action='append', metavar='<submit-line>')

args = argparser.parse_args()

xgroups = None
if len(args.xgroups_args) > 0:
    try:
        xgroups = {}
        j=0
        while ((j+1) < len(args.xgroups_args)):
            tn = int(args.xgroups_args[j+1])
            xgroups[args.xgroups_args[j]] = tn
            j += 2
        if j < len(args.xgroups_args):
            raise Exception()
    except:
        argparser.print_usage()
        sys.exit(1)


shcmd = ""
if args.shell:
    cpath = sys.argv[0]
    j = cpath.rfind('/')
    if j>=0: cpath = cpath[:j]
    else:    cpath = "."
    shcmd = "%s/shcmd" % (cpath)
    if not os.path.exists(shcmd):
        print "Could not find %s" % (shcmd)
        sys.exit(1)

jsub_dir = tempfile.mkdtemp(prefix='cjs_jsub_')
print "using temp dir %s for jsub files" % (jsub_dir)

# open a temporary submission file
jsfile_name = "%s/cjs.jsub" % (jsub_dir)
print "preparing %d jobs in submission file: %s" % (args.n, jsfile_name)
jsfile = open(jsfile_name, 'wb')

# jsub "header" stuff
jsfile.write("universe = vanilla\n")

if args.shell:
    jsfile.write("cmd = %s\n" % (shcmd))
    jsfile.write("args = /bin/sleep %d\n" % (args.duration))
else:
    jsfile.write("cmd = /bin/sleep\n")
    jsfile.write("args = %d\n" % (args.duration))

if args.std_out:
    jsfile.write("output = %s/std.$(cluster).$(process)\n" % (jsub_dir))
if args.err_out:
    jsfile.write("error = %s/err.$(cluster).$(process)\n" % (jsub_dir))
if args.log_out:
    jsfile.write("log = %s/log.$(cluster).$(process)\n" % (jsub_dir))

jsfile.write("should_transfer_files = if_needed\n")
jsfile.write("when_to_transfer_output = on_exit\n")

if args.reqs != None:
    jsfile.write("requirements = (%s)\n" % (args.reqs))

for aline in args.append:
    jsfile.write("%s\n" % (aline))

nsub = 0

if xgroups != None:
    # construct using the groups and counts given in '-xgroups'
    nsub = 0
    for k in xgroups.keys():
        gn = xgroups[k]
        jsfile.write("+AccountingGroup=\"%s.user\"\n" % (k))
        jsfile.write("queue %d\n" % (gn))
        nsub += gn
else:
    # construct using (n) and (submitters)
    u_inc = float(args.n)/float(args.submitters)
    u_sum = 0.0
    u_max = float(args.n)
    u_cnt = 0
    u = 0
    j = 0
    while j < args.submitters:
        u_sum += u_inc
        u = int(u_sum)
        u_sum -= float(u)

        # Handle corner cases from roundoff err.
        # Correction shouldn't actually exceed 1
        u_cnt += u
        if (j == (args.submitters-1)) and (u_cnt < args.n):
            d = args.n-u_cnt
            u += d
            u_cnt += d

        jsfile.write("+AccountingGroup = \"%s\"\n" % ("none.user%04d" % j))
        jsfile.write("queue %d\n" % (u))
        j += 1
    nsub = u_cnt

jsfile.close()

if not args.ss:
    print "submitting %d jobs via jsub file %s" % (nsub, jsfile_name)
    # submit the file
    rc = subprocess.call(["condor_submit", jsfile_name])
    if rc == 0:
        print "submit was successful"
    else:
        print "WARNING! submit failed with code %d" % rc
else:
    # steady-state submission mode
    reps = 0
    t0 = float(time.time())
    tL = float(0)
    while True:
        tC = float(time.time())
        tS = args.interval - (tC-tL)
        if tS > 0: time.sleep(tS)
        tL = float(time.time())
        elapsed = int(tL - t0)
        if (args.maxtime != None) and (elapsed >= args.maxtime): break
        reps += 1
        if (args.maxreps != None) and (reps > args.maxreps): break
        sys.stdout.write("submission rep= %d, elapsed= %d\n" % (reps, elapsed))
        rc = subprocess.call(["condor_submit", jsfile_name])
        if rc != 0:
            sys.stderr.write("submit was not successful!\n")
